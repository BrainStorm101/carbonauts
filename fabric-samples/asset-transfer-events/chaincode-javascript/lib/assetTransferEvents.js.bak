/*
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';

const { Contract } = require('fabric-contract-api');

// Credit status constants
const CREDIT_STATUS = {
    AVAILABLE: 'AVAILABLE',
    FOR_SALE: 'FOR_SALE',
    SOLD_ESCROW: 'SOLD_ESCROW',
    FINALIZED: 'FINALIZED',
    REVOKED: 'REVOKED'
};

// Remove stringify function since we're using JSON.stringify directly

function sortKeysRecursive(obj) {
	if (typeof obj !== 'object' || obj === null) {
		return obj;
	}
	if (Array.isArray(obj)) {
		return obj.map(sortKeysRecursive);
	}
	const sortedKeys = Object.keys(obj).sort();
	const result = {};
	for (const key of sortedKeys) {
		result[key] = sortKeysRecursive(obj[key]);
	}
	return result;
}


class BlueCarbonRegistry extends Contract {

	// Initialize the ledger with default data
	async InitLedger(ctx) {
		console.info('============= START : Initialize Ledger ===========');

		// Initialize system configuration
		const systemConfig = {
			docType: 'systemConfig',
			version: '1.0.0',
			carbonCreditRate: 0.5, // Credits per tree planted
			auditPeriodDays: 30,
			escrowPeriodDays: 1, // Set to 1 day for testing
			minimumApprovals: 1, // Only NCCR approval required
			marketplaceFeePercent: 2.5 // Platform fee percentage
		};

		await ctx.stub.putState('SYSTEM_CONFIG', Buffer.from(JSON.stringify(sortKeysRecursive(systemConfig))));

		// Initialize user roles enum
		const userRoles = {
			FARMER: 'FARMER',
			NGO: 'NGO',
			NCCR: 'NCCR',
			INDUSTRY: 'INDUSTRY'
		};

		await ctx.stub.putState('USER_ROLES', Buffer.from(JSON.stringify(sortKeysRecursive(userRoles))));

		console.info('============= END : Initialize Ledger ===========');
	}

	// ==================== USER MANAGEMENT ====================

	async RegisterUser(ctx, userId, name, role, organization, contactInfo) {
		console.info('============= START : Register User ===========');

		// Check if user already exists
		const existingUserBytes = await ctx.stub.getState(userId);
		if (existingUserBytes && existingUserBytes.length > 0) {
			throw new Error(`User with ID '${userId}' already exists. Use a different user ID.`);
		}

		const userRolesBuffer = await ctx.stub.getState('USER_ROLES');
		const userRoles = JSON.parse(userRolesBuffer.toString());

		if (!Object.values(userRoles).includes(role)) {
			throw new Error(`Invalid role: ${role}`);
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		const user = {
			docType: 'user',
			userId: userId,
			name: name,
			role: role,
			organization: organization,
			contactInfo: contactInfo,
			isActive: true,
			registeredAt: timestamp,
			verificationStatus: role === 'FARMER' ? 'PENDING' : 'VERIFIED'
		};

		await ctx.stub.putState(userId, Buffer.from(JSON.stringify(sortKeysRecursive(user))));

		// Emit event
		ctx.stub.setEvent('UserRegistered', Buffer.from(JSON.stringify(user)));

		console.info('============= END : Register User ===========');
		return JSON.stringify(user);
	}

	async GetUser(ctx, userId) {
		const userAsBytes = await ctx.stub.getState(userId);
		if (!userAsBytes || userAsBytes.length === 0) {
			throw new Error(`User ${userId} does not exist`);
		}
		return userAsBytes.toString();
	}

	async VerifyUser(ctx, userId, verifierId) {
		console.info('============= START : Verify User ===========');

		// Get the user to be verified
		const userAsBytes = await ctx.stub.getState(userId);
		if (!userAsBytes || userAsBytes.length === 0) {
			throw new Error(`User ${userId} does not exist`);
		}

		const user = JSON.parse(userAsBytes.toString());
		if (user.docType !== 'user') {
			throw new Error(`Entity ${userId} is not a user`);
		}

		// Get the verifier
		const verifierAsBytes = await ctx.stub.getState(verifierId);
		if (!verifierAsBytes || verifierAsBytes.length === 0) {
			throw new Error(`Verifier ${verifierId} does not exist`);
		}

		const verifier = JSON.parse(verifierAsBytes.toString());
		if (verifier.docType !== 'user') {
			throw new Error(`Entity ${verifierId} is not a user`);
		}

		// Check if verifier has authorization (NGO or NCCR can verify users)
		if (verifier.role !== 'NGO' && verifier.role !== 'NCCR') {
			throw new Error(`User ${verifierId} with role ${verifier.role} cannot verify users. Only NGO and NCCR can verify users.`);
		}

		// Check if verifier is verified themselves
		if (verifier.verificationStatus !== 'VERIFIED') {
			throw new Error(`Verifier ${verifierId} must be verified to verify other users`);
		}

		// Check if user is already verified
		if (user.verificationStatus === 'VERIFIED') {
			throw new Error(`User ${userId} is already verified`);
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		// Update user verification status
		user.verificationStatus = 'VERIFIED';
		user.verifiedBy = verifierId;
		user.verifiedAt = timestamp;

		await ctx.stub.putState(userId, Buffer.from(JSON.stringify(sortKeysRecursive(user))));

		// Create audit trail entry
		await this._createAuditEntry(ctx, userId, 'USER_VERIFIED', verifierId, `User verified by ${verifier.role} ${verifierId}`);

		// Emit event
		ctx.stub.setEvent('UserVerified', Buffer.from(JSON.stringify(user)));

		console.info('============= END : Verify User ===========');
		return JSON.stringify(user);
	}

	async GetAllUsers(ctx) {
		console.info('============= START : Get All Users ===========');

		const queryString = {
			selector: {
				docType: 'user'
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);

		console.info('============= END : Get All Users ===========');
		return JSON.stringify(results);
	}

	// ==================== PROJECT MANAGEMENT ====================

	async CreateProject(ctx, projectId, name, location, coordinates, projectType, targetTrees, ngoId) {
		console.info('============= START : Create Project ===========');

		// Verify NGO exists and has correct role
		try {
			const ngoUser = JSON.parse(await this.GetUser(ctx, ngoId));
			if (ngoUser.role !== 'NGO') {
				throw new Error('Only NGOs can create projects');
			}
		} catch (error) {
			console.warn(`Warning: Could not verify NGO user ${ngoId}: ${error.message}`);
			// Continue with project creation - user verification can be done later
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		const project = {
			docType: 'project',
			projectId: projectId,
			name: name,
			location: location,
			coordinates: coordinates, // {lat, lng, boundary}
			projectType: projectType, // MANGROVE, SEAGRASS, TREES
			targetTrees: parseInt(targetTrees),
			currentTrees: 0,
			ngoId: ngoId,
			status: 'ACTIVE',
			createdAt: timestamp,
			creditsGenerated: 0,
			creditsAvailable: 0
		};

		await ctx.stub.putState(projectId, Buffer.from(JSON.stringify(sortKeysRecursive(project))));

		// Emit event
		ctx.stub.setEvent('ProjectCreated', Buffer.from(JSON.stringify(project)));

		console.info('============= END : Create Project ===========');
		return JSON.stringify(project);
	}

	async GetProject(ctx, projectId) {
		const projectAsBytes = await ctx.stub.getState(projectId);
		if (!projectAsBytes || projectAsBytes.length === 0) {
			throw new Error(`Project ${projectId} does not exist`);
		}
		return projectAsBytes.toString();
	}

	// ==================== SUBMISSION WORKFLOW ====================

	async CreateSubmission(ctx, submissionId, farmerId, projectId, plantType, numberOfSamples, imageHashes, gpsCoordinates, deviceSignature) {
		console.info('============= START : Create Submission ===========');

		// Verify farmer exists
		try {
			const farmer = JSON.parse(await this.GetUser(ctx, farmerId));
			if (farmer.role !== 'FARMER') {
				throw new Error('Only farmers can create submissions');
			}
		} catch (error) {
			console.warn(`Warning: Could not verify farmer user ${farmerId}: ${error.message}`);
			// Continue with submission creation - user verification can be done later
		}

		// Verify project exists
		// const project = JSON.parse(await this.GetProject(ctx, projectId));

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		const submission = {
			docType: 'submission',
			submissionId: submissionId,
			farmerId: farmerId,
			projectId: projectId,
			plantType: plantType,
			numberOfSamples: parseInt(numberOfSamples),
			imageHashes: JSON.parse(imageHashes), // Array of IPFS hashes
			gpsCoordinates: JSON.parse(gpsCoordinates), // {lat, lng, accuracy}
			deviceSignature: deviceSignature,
			status: 'PENDING_REVIEW',
			submittedAt: timestamp,
			reviewedBy: [],
			approvals: [],
			rejectionReason: null,
			creditsEarned: 0
		};

		await ctx.stub.putState(submissionId, Buffer.from(JSON.stringify(sortKeysRecursive(submission))));

		// Create audit trail entry
		await this._createAuditEntry(ctx, submissionId, 'SUBMISSION_CREATED', farmerId, `Submission created with ${numberOfSamples} samples`);

		// Emit event
		ctx.stub.setEvent('SubmissionCreated', Buffer.from(JSON.stringify(submission)));

		console.info('============= END : Create Submission ===========');
		return JSON.stringify(submission);
	}

	// ==================== SUBMISSION REVIEW ====================
	async ReviewSubmission(ctx, submissionId, reviewerId, action, comments) {
		console.info('============= START : Review Submission ===========');

		// Verify reviewer exists and has proper permissions
		let reviewerJson = await this.GetUser(ctx, reviewerId);
		if (!reviewerJson) {
			throw new Error(`Reviewer user '${reviewerId}' does not exist on the ledger`);
		}

		let reviewer;
		try {
			reviewer = JSON.parse(reviewerJson);
		} catch (err) {
			throw new Error(`Failed to parse reviewer data for user '${reviewerId}': ${err.message}`);
		}

		// Validate reviewer role
		if (reviewer.role !== 'NCCR') {
			throw new Error(`User '${reviewerId}' has role '${reviewer.role}' but only NCCR users can review submissions`);
		}

		// Validate reviewer verification status
		if (reviewer.verificationStatus !== 'VERIFIED') {
			throw new Error(`Reviewer '${reviewerId}' has verification status '${reviewer.verificationStatus}' but must be VERIFIED`);
		}

		// Validate reviewer is active
		if (!reviewer.isActive) {
			throw new Error(`Reviewer '${reviewerId}' is not active`);
		}

		const submissionAsBytes = await ctx.stub.getState(submissionId);
		const submission = JSON.parse(submissionAsBytes.toString());

		if (submission.status !== 'PENDING_REVIEW' && submission.status !== 'UNDER_REVIEW') {
			throw new Error(`Cannot review submission with status: ${submission.status}`);
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		// Add review
		const review = {
			reviewerId: reviewerId,
			reviewerRole: reviewer.role,
			action: action, // APPROVE, REJECT, REQUEST_MORE_INFO
			comments: comments,
			reviewedAt: timestamp
		};

		submission.reviewedBy.push(review);

		if (action === 'APPROVE') {
			submission.status = 'APPROVED';
			submission.approvals.push(reviewerId);
			// Calculate credits earned
			const systemConfig = JSON.parse((await ctx.stub.getState('SYSTEM_CONFIG')).toString());
			submission.creditsEarned = submission.numberOfSamples * systemConfig.carbonCreditRate;
		} else if (action === 'REJECT') {
			submission.status = 'REJECTED';
			submission.rejectionReason = comments;
		}

		await ctx.stub.putState(submissionId, Buffer.from(JSON.stringify(sortKeysRecursive(submission))));

		// Create audit trail entry
		await this._createAuditEntry(ctx, submissionId, `SUBMISSION_${action}`, reviewerId, comments);

		// Emit event
		ctx.stub.setEvent('SubmissionReviewed', Buffer.from(JSON.stringify(submission)));

		console.info('============= END : Review Submission ===========');
		return JSON.stringify(submission);
	}

	async GetUserById(ctx, userId) {
		const userBytes = await ctx.stub.getState(userId);
		if (!userBytes || userBytes.length === 0) {
			throw new Error(`User ${userId} not found`);
		}
		return userBytes.toString();
	}

	// ==============Allow NCCR or AUDITOR to verify a project before submissions start.==============
	async VerifyProject(ctx, projectId, verifierId, comments) {
		console.info('============= START : Verify Project ===========');

		try {
			const verifier = JSON.parse(await this.GetUser(ctx, verifierId));
			if (verifier.role !== 'NCCR') {
				throw new Error('Only NCCR can verify projects');
			}
		} catch (error) {
			console.warn(`Warning: Could not verify NCCR user ${verifierId}: ${error.message}`);
			// Continue with project verification - user verification can be done later
		}

		const projectAsBytes = await ctx.stub.getState(projectId);
		if (!projectAsBytes || projectAsBytes.length === 0) {
			throw new Error(`Project ${projectId} does not exist`);
		}

		const project = JSON.parse(projectAsBytes.toString());
		if (project.status !== 'ACTIVE') {
			throw new Error(`Cannot verify project with status: ${project.status}`);
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		project.status = 'VERIFIED';
		project.verifiedBy = verifierId;
		project.verifiedAt = timestamp;

		await ctx.stub.putState(projectId, Buffer.from(JSON.stringify(sortKeysRecursive(project))));
		await this._createAuditEntry(ctx, projectId, 'PROJECT_VERIFIED', verifierId, comments);

		ctx.stub.setEvent('ProjectVerified', Buffer.from(JSON.stringify(project)));

		console.info('============= END : Verify Project ===========');
		return JSON.stringify(project);
	}


	// ==================== CARBON CREDIT TOKENIZATION ====================

	async MintCarbonCredits(ctx, submissionId, nccr_id) {
		console.info('============= START : Mint Carbon Credits ===========');

		// Verify NCCR authority
		const nccr = JSON.parse(await this.GetUser(ctx, nccr_id));
		if (nccr.role !== 'NCCR') {
			throw new Error('Only NCCR can mint carbon credits');
		}

		const submissionAsBytes = await ctx.stub.getState(submissionId);
		const submission = JSON.parse(submissionAsBytes.toString());

		if (submission.status !== 'APPROVED') {
			throw new Error('Can only mint credits for approved submissions');
		}

		if (submission.creditsEarned <= 0) {
			throw new Error('No credits to mint for this submission');
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		// Generate unique credit batch ID using deterministic timestamp
		const creditBatchId = `CREDIT_${submissionId}_${txTimestamp.seconds}`;

		const carbonCredit = {
			docType: 'carbonCredit',
			creditBatchId: creditBatchId,
			submissionId: submissionId,
			projectId: submission.projectId,
			farmerId: submission.farmerId,
			creditsAmount: submission.creditsEarned,
			creditType: submission.plantType,
			status: 'AVAILABLE',
			mintedAt: timestamp,
			mintedBy: nccr_id,
			purchasedBy: null,
			purchasedAt: null,
			pricePerCredit: 0,
			escrowUntil: null,
			certificateHash: null
		};

		await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(carbonCredit))));

		// Update project stats
		const projectAsBytes = await ctx.stub.getState(submission.projectId);
		const project = JSON.parse(projectAsBytes.toString());
		project.currentTrees += submission.numberOfSamples;
		project.creditsGenerated += submission.creditsEarned;
		project.creditsAvailable += submission.creditsEarned;
		await ctx.stub.putState(submission.projectId, Buffer.from(JSON.stringify(sortKeysRecursive(project))));

		// Update submission status
		submission.status = 'CREDITS_MINTED';
		await ctx.stub.putState(submissionId, Buffer.from(JSON.stringify(sortKeysRecursive(submission))));

		// Create audit trail entry
		await this._createAuditEntry(ctx, creditBatchId, 'CREDITS_MINTED', nccr_id, `Minted ${submission.creditsEarned} credits`);

		// Emit event
		ctx.stub.setEvent('CreditsMinted', Buffer.from(JSON.stringify(carbonCredit)));

		console.info('============= END : Mint Carbon Credits ===========');
		return JSON.stringify(carbonCredit);
	}

	// ==================== MARKETPLACE FUNCTIONS ====================

	async ListCreditsForSale(ctx, creditBatchId, pricePerCredit, sellerId) {
		console.info('============= START : List Credits For Sale ===========');

		const creditAsBytes = await ctx.stub.getState(creditBatchId);
		const credit = JSON.parse(creditAsBytes.toString());

		if (credit.status !== 'AVAILABLE') {
			throw new Error('Credits are not available for sale');
		}

		// Verify seller is the farmer who owns the credits
		if (credit.farmerId !== sellerId) {
			throw new Error('Only the farmer who owns the credits can list them for sale');
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		credit.status = 'FOR_SALE';
		credit.pricePerCredit = parseFloat(pricePerCredit);
		credit.listedBy = sellerId;
		credit.listedAt = timestamp;

		await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(credit))));

		await this._createAuditEntry(ctx, creditBatchId, 'CREDITS_LISTED', sellerId, `Listed for sale at ${pricePerCredit} per credit`);

		// Emit event
		ctx.stub.setEvent('CreditsListed', Buffer.from(JSON.stringify(credit)));

		console.info('============= END : List Credits For Sale ===========');
		return JSON.stringify(credit);
	}

	async PurchaseCredits(ctx, creditBatchId, buyerId, paymentAmount) {
		console.info('============= START : Purchase Credits ===========');

		// Verify buyer is industry
		const buyer = JSON.parse(await this.GetUser(ctx, buyerId));
		if (buyer.role !== 'INDUSTRY') {
			throw new Error('Only industries can purchase credits');
		}

		const creditAsBytes = await ctx.stub.getState(creditBatchId);
		const credit = JSON.parse(creditAsBytes.toString());

		if (credit.status !== 'FOR_SALE') {
			throw new Error('Credits are not available for purchase');
		}

		const totalPrice = credit.creditsAmount * credit.pricePerCredit;
		if (parseFloat(paymentAmount) < totalPrice) {
			throw new Error(`Insufficient payment. Required: ${totalPrice}, Provided: ${paymentAmount}`);
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		// Set escrow period
		const systemConfig = JSON.parse((await ctx.stub.getState('SYSTEM_CONFIG')).toString());
		const escrowDate = new Date(txTimestamp.seconds * 1000);
		escrowDate.setDate(escrowDate.getDate() + systemConfig.escrowPeriodDays);

		credit.status = 'SOLD_ESCROW';
		credit.purchasedBy = buyerId;
		credit.purchasedAt = timestamp;
		credit.escrowUntil = escrowDate.toISOString();
		credit.paymentAmount = parseFloat(paymentAmount);

		await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(credit))));

		// Update project available credits
		const projectAsBytes = await ctx.stub.getState(credit.projectId);
		const project = JSON.parse(projectAsBytes.toString());
		project.creditsAvailable -= credit.creditsAmount;
		await ctx.stub.putState(credit.projectId, Buffer.from(JSON.stringify(sortKeysRecursive(project))));

		await this._createAuditEntry(ctx, creditBatchId, 'CREDITS_PURCHASED', buyerId, `Purchased ${credit.creditsAmount} credits for ${paymentAmount}`);

		// Emit event
		ctx.stub.setEvent('CreditsPurchased', Buffer.from(JSON.stringify(credit)));

		console.info('============= END : Purchase Credits ===========');
		return JSON.stringify(credit);
	}

	async FinalizeCredits(ctx, creditBatchId, certificateHash) {
		console.info('============= START : Finalize Credits ===========');

		const creditAsBytes = await ctx.stub.getState(creditBatchId);
		const credit = JSON.parse(creditAsBytes.toString());

		if (credit.status !== 'SOLD_ESCROW') {
			throw new Error('Credits are not in escrow status');
		}

		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();

		// Check if escrow period has passed
		const now = new Date(txTimestamp.seconds * 1000);
		const escrowDate = new Date(credit.escrowUntil);

		if (now < escrowDate) {
			throw new Error('Escrow period has not ended yet');
		}

		credit.status = 'FINALIZED';
		credit.certificateHash = certificateHash;
		credit.finalizedAt = timestamp;

		await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(credit))));

		await this._createAuditEntry(ctx, creditBatchId, 'CREDITS_FINALIZED', 'SYSTEM', 'Credits finalized after escrow period');

		// Emit event
		ctx.stub.setEvent('CreditsFinalized', Buffer.from(JSON.stringify(credit)));

		console.info('============= END : Finalize Credits ===========');
		return JSON.stringify(credit);
	}

	// ==================== QUERY FUNCTIONS ====================

	async QuerySubmissionsByFarmer(ctx, farmerId) {
		const queryString = {
			selector: {
				docType: 'submission',
				farmerId: farmerId
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	async QuerySubmissionsByProject(ctx, projectId) {
		const queryString = {
			selector: {
				docType: 'submission',
				projectId: projectId
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	async QueryPendingSubmissions(ctx) {
		const allResults = [];
		const iterator = await ctx.stub.getStateByRange('', '');
		let result = await iterator.next();

		while (!result.done) {
			const strValue = Buffer.from(result.value.value.toString()).toString('utf8');
			let record;
			try {
				record = JSON.parse(strValue);
				// Filter for pending submissions
				if (record.docType === 'submission' && record.status === 'PENDING_REVIEW') {
					allResults.push({ Key: result.value.key, Record: record });
				}
			} catch (err) {
				console.log(err);
			}
			result = await iterator.next();
		}

		return JSON.stringify(allResults);
	}

	async QueryAvailableCredits(ctx) {
		const queryString = {
			selector: {
				docType: 'carbonCredit',
				status: 'FOR_SALE'
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	async QueryCreditsByIndustry(ctx, industryId) {
		const queryString = {
			selector: {
				docType: 'carbonCredit',
				purchasedBy: industryId
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	async QueryCreditsByFarmer(ctx, farmerId) {
		const queryString = {
			selector: {
				docType: 'carbonCredit',
				farmerId: farmerId
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	async GetProjectStats(ctx, projectId) {
		const project = JSON.parse(await this.GetProject(ctx, projectId));

		// Get submission count
		const submissionQuery = {
			selector: {
				docType: 'submission',
				projectId: projectId
			}
		};

		const submissionIterator = await ctx.stub.getQueryResult(JSON.stringify(submissionQuery));
		const submissions = await this._getAllResults(submissionIterator);

		const stats = {
			project: project,
			totalSubmissions: submissions.length,
			approvedSubmissions: submissions.filter(s => s.Record.status === 'APPROVED' || s.Record.status === 'CREDITS_MINTED').length,
			pendingSubmissions: submissions.filter(s => s.Record.status === 'PENDING_REVIEW' || s.Record.status === 'UNDER_REVIEW').length,
			rejectedSubmissions: submissions.filter(s => s.Record.status === 'REJECTED').length,
			completionPercentage: (project.currentTrees / project.targetTrees) * 100
		};

		return JSON.stringify(stats);
	}

	// GetAllAssets returns all assets found in the world state.
	async GetAllAssets(ctx) {
		const allResults = [];
		// range query with empty string for startKey and endKey does an open-ended query of all assets in the chaincode namespace.
		const iterator = await ctx.stub.getStateByRange('', '');
		let result = await iterator.next();
		while (!result.done) {
			const strValue = Buffer.from(result.value.value.toString()).toString('utf8');
			let record;
			try {
				record = JSON.parse(strValue);
			} catch (err) {
				console.log(err);
				record = strValue;
			}
			allResults.push(record);
			result = await iterator.next();
		}
		return JSON.stringify(allResults);
	}

	// ==================== AUDIT TRAIL ====================

	async _createAuditEntry(ctx, entityId, action, userId, details) {
		// Use deterministic timestamp from transaction
		const txTimestamp = ctx.stub.getTxTimestamp();
		const timestamp = new Date(txTimestamp.seconds * 1000).toISOString();
		const auditId = `AUDIT_${entityId}_${txTimestamp.seconds}`;

		const auditEntry = {
			docType: 'auditEntry',
			auditId: auditId,
			entityId: entityId,
			action: action,
			userId: userId,
			details: details,
			timestamp: timestamp,
			blockNumber: ctx.stub.getTxID()
		};

		await ctx.stub.putState(auditId, Buffer.from(JSON.stringify(sortKeysRecursive(auditEntry))));
	}

	async GetAuditTrail(ctx, entityId) {
		const queryString = {
			selector: {
				docType: 'auditEntry',
				entityId: entityId
			},
			sort: [{ timestamp: 'desc' }]
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}

	    // ==================== MARKETPLACE FUNCTIONS ====================

    async ListCreditsForSale(ctx, creditBatchId, pricePerCredit, sellerId) {
        console.info('============= START : List Credits For Sale ===========');

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate ownership
        if (creditBatch.ownerId !== sellerId) {
            throw new Error('Only the owner can list credits for sale');
        }

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.AVAILABLE) {
            throw new Error('Only AVAILABLE credits can be listed for sale');
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.FOR_SALE;
        creditBatch.pricePerCredit = parseFloat(pricePerCredit);
        creditBatch.listedAt = new Date().toISOString();

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsListedForSale', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            sellerId: sellerId,
            pricePerCredit: pricePerCredit,
            quantity: creditBatch.quantity
        })));

        console.info('============= END : List Credits For Sale ===========');
        return JSON.stringify(creditBatch);
    }

    async PurchaseCredits(ctx, creditBatchId, buyerId, paymentAmount) {
        console.info('============= START : Purchase Credits ===========');

        // Get buyer info
        const buyerBytes = await ctx.stub.getState(buyerId);
        if (!buyerBytes || buyerBytes.length === 0) {
            throw new Error(`Buyer ${buyerId} does not exist`);
        }
        const buyer = JSON.parse(buyerBytes.toString());

        // Verify buyer is an industry user
        if (buyer.role !== 'INDUSTRY') {
            throw new Error('Only INDUSTRY users can purchase credits');
        }

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.FOR_SALE) {
            throw new Error('Credits are not available for purchase');
        }

        // Calculate total price
        const totalPrice = creditBatch.quantity * creditBatch.pricePerCredit;
        if (parseFloat(paymentAmount) < totalPrice) {
            throw new Error(`Insufficient payment. Required: ${totalPrice}, Received: ${paymentAmount}`);
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.SOLD_ESCROW;
        creditBatch.buyerId = buyerId;
        creditBatch.soldAt = new Date().toISOString();
        
        // Get system config for escrow period
        const systemConfigBytes = await ctx.stub.getState('SYSTEM_CONFIG');
        const systemConfig = JSON.parse(systemConfigBytes.toString());
        const escrowPeriodDays = systemConfig.escrowPeriodDays || 1;
        
        creditBatch.escrowReleaseTime = new Date(Date.now() + escrowPeriodDays * 24 * 60 * 60 * 1000).toISOString();

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsPurchased', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            buyerId: buyerId,
            sellerId: creditBatch.ownerId,
            quantity: creditBatch.quantity,
            totalPrice: totalPrice
        })));

        console.info('============= END : Purchase Credits ===========');
        return JSON.stringify(creditBatch);
    }

    async FinalizeCredits(ctx, creditBatchId, certificateHash) {
        console.info('============= START : Finalize Credits ===========');

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.SOLD_ESCROW) {
            throw new Error('Only SOLD_ESCROW credits can be finalized');
        }

        // Check if escrow period has passed
        const escrowEndTime = new Date(creditBatch.escrowReleaseTime).getTime();
        const currentTime = new Date().getTime();
        
        if (currentTime < escrowEndTime) {
            throw new Error(`Escrow period has not ended. Can finalize after: ${creditBatch.escrowReleaseTime}`);
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.FINALIZED;
        creditBatch.certificateHash = certificateHash;
        creditBatch.finalizedAt = new Date().toISOString();
        
        // Transfer ownership to buyer
        creditBatch.ownerId = creditBatch.buyerId;
        delete creditBatch.buyerId;

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsFinalized', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            ownerId: creditBatch.ownerId,
            certificateHash: certificateHash
        })));

        console.info('============= END : Finalize Credits ===========');
        return JSON.stringify(creditBatch);
    }

    // ==================== QUERY FUNCTIONS ====================

    async QueryAvailableCredits(ctx) {
        console.info('============= START : Query Available Credits ===========');
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                status: CREDIT_STATUS.FOR_SALE
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info('============= END : Query Available Credits ===========');
        return JSON.stringify(results);
    }

    async QueryCreditsByFarmer(ctx, farmerId) {
        console.info(`============= START : Query Credits for Farmer ${farmerId} ===========`);
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                farmerId: farmerId
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info(`============= END : Query Credits for Farmer ${farmerId} ===========`);
        return JSON.stringify(results);
    }

    async QueryCreditsByIndustry(ctx, industryId) {
        console.info(`============= START : Query Credits for Industry ${industryId} ===========`);
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                ownerId: industryId,
                status: CREDIT_STATUS.FINALIZED
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info(`============= END : Query Credits for Industry ${industryId} ===========`);
        return JSON.stringify(results);
    }

    async GetProjectStats(ctx, projectId) {
        console.info(`============= START : Get Project Stats for ${projectId} ===========`);
        
        // Get all credits for this project
        const queryString = {
            selector: {
                docType: 'creditBatch',
                projectId: projectId
            }
        };

        let totalCredits = 0;
        let availableCredits = 0;
        let soldCredits = 0;
        let pendingCredits = 0;
        const creditBatches = [];

        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            const creditBatch = JSON.parse(value.toString());
            creditBatches.push(creditBatch);
            totalCredits += creditBatch.quantity;
            
            if (creditBatch.status === CREDIT_STATUS.AVAILABLE || creditBatch.status === CREDIT_STATUS.FOR_SALE) {
                availableCredits += creditBatch.quantity;
            } else if (creditBatch.status === CREDIT_STATUS.FINALIZED) {
                soldCredits += creditBatch.quantity;
            } else if (creditBatch.status === CREDIT_STATUS.SOLD_ESCROW) {
                pendingCredits += creditBatch.quantity;
            }
        }

        const stats = {
            projectId: projectId,
            totalCredits: totalCredits,
            availableCredits: availableCredits,
            soldCredits: soldCredits,
            pendingCredits: pendingCredits,
            creditBatches: creditBatches
        };

        console.info('============= END : Get Project Stats ===========');
        return JSON.stringify(stats);
    }

    async QueryPendingSubmissions(ctx) {
        console.info('============= START : Query Pending Submissions ===========');
        
        const queryString = {
            selector: {
                docType: 'submission',
                status: 'PENDING'
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info('============= END : Query Pending Submissions ===========');
        return JSON.stringify(results);
    }

    async UpdateSystemConfig(ctx, key, value) {
        console.info(`============= START : Update System Config ${key} ===========`);
        
        // Get system config
        const systemConfigBytes = await ctx.stub.getState('SYSTEM_CONFIG');
        if (!systemConfigBytes || systemConfigBytes.length === 0) {
            throw new Error('System configuration not found');
        }
        const systemConfig = JSON.parse(systemConfigBytes.toString());

        // Update the specified key
        if (key === 'escrowPeriodDays' || key === 'auditPeriodDays' || key === 'minimumApprovals') {
            systemConfig[key] = parseInt(value);
        } else if (key === 'carbonCreditRate' || key === 'marketplaceFeePercent') {
            systemConfig[key] = parseFloat(value);
        } else {
            systemConfig[key] = value;
        }

        // Save updated config
        await ctx.stub.putState('SYSTEM_CONFIG', Buffer.from(JSON.stringify(sortKeysRecursive(systemConfig))));

        console.info(`============= END : Update System Config ${key} ===========`);
        return JSON.stringify(systemConfig);
    }

    // ==================== HELPER FUNCTIONS ====================

    async _getAllResults(iterator) {
		const allResults = [];
		let result = await iterator.next();

		while (!result.done) {
			const strValue = Buffer.from(result.value.value.toString()).toString('utf8');
			let record;
			try {
				record = JSON.parse(strValue);
			} catch (err) {
				console.log(err);
				record = strValue;
			}
			allResults.push({ Key: result.value.key, Record: record });
			result = await iterator.next();
		}

		return allResults;
	}

	// Get all entities of a specific type
	async GetAllEntities(ctx, docType) {
		const queryString = {
			selector: {
				docType: docType
			}
		};

		const resultsIterator = await ctx.stub.getQueryResult(JSON.stringify(queryString));
		const results = await this._getAllResults(resultsIterator);
		return JSON.stringify(results);
	}
}

    // ==================== MARKETPLACE FUNCTIONS ====================

    async ListCreditsForSale(ctx, creditBatchId, pricePerCredit, sellerId) {
        console.info('============= START : List Credits For Sale ===========');

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate ownership
        if (creditBatch.ownerId !== sellerId) {
            throw new Error('Only the owner can list credits for sale');
        }

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.AVAILABLE) {
            throw new Error('Only AVAILABLE credits can be listed for sale');
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.FOR_SALE;
        creditBatch.pricePerCredit = parseFloat(pricePerCredit);
        creditBatch.listedAt = new Date().toISOString();

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsListedForSale', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            sellerId: sellerId,
            pricePerCredit: pricePerCredit,
            quantity: creditBatch.quantity
        })));

        console.info('============= END : List Credits For Sale ===========');
        return JSON.stringify(creditBatch);
    }

    async PurchaseCredits(ctx, creditBatchId, buyerId, paymentAmount) {
        console.info('============= START : Purchase Credits ===========');

        // Get buyer info
        const buyerBytes = await ctx.stub.getState(buyerId);
        if (!buyerBytes || buyerBytes.length === 0) {
            throw new Error(`Buyer ${buyerId} does not exist`);
        }
        const buyer = JSON.parse(buyerBytes.toString());

        // Verify buyer is an industry user
        if (buyer.role !== 'INDUSTRY') {
            throw new Error('Only INDUSTRY users can purchase credits');
        }

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.FOR_SALE) {
            throw new Error('Credits are not available for purchase');
        }

        // Calculate total price
        const totalPrice = creditBatch.quantity * creditBatch.pricePerCredit;
        if (parseFloat(paymentAmount) < totalPrice) {
            throw new Error(`Insufficient payment. Required: ${totalPrice}, Received: ${paymentAmount}`);
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.SOLD_ESCROW;
        creditBatch.buyerId = buyerId;
        creditBatch.soldAt = new Date().toISOString();
        creditBatch.escrowReleaseTime = new Date(Date.now() + (creditBatch.escrowPeriodDays || 1) * 24 * 60 * 60 * 1000).toISOString();

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsPurchased', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            buyerId: buyerId,
            sellerId: creditBatch.ownerId,
            quantity: creditBatch.quantity,
            totalPrice: totalPrice
        })));

        console.info('============= END : Purchase Credits ===========');
        return JSON.stringify(creditBatch);
    }

    async FinalizeCredits(ctx, creditBatchId, certificateHash) {
        console.info('============= START : Finalize Credits ===========');

        // Get the credit batch
        const creditBatchBytes = await ctx.stub.getState(creditBatchId);
        if (!creditBatchBytes || creditBatchBytes.length === 0) {
            throw new Error(`Credit batch ${creditBatchId} does not exist`);
        }
        const creditBatch = JSON.parse(creditBatchBytes.toString());

        // Validate status
        if (creditBatch.status !== CREDIT_STATUS.SOLD_ESCROW) {
            throw new Error('Only SOLD_ESCROW credits can be finalized');
        }

        // Check if escrow period has passed
        const escrowEndTime = new Date(creditBatch.escrowReleaseTime).getTime();
        const currentTime = new Date().getTime();
        
        if (currentTime < escrowEndTime) {
            throw new Error(`Escrow period has not ended. Can finalize after: ${creditBatch.escrowReleaseTime}`);
        }

        // Update credit batch
        creditBatch.status = CREDIT_STATUS.FINALIZED;
        creditBatch.certificateHash = certificateHash;
        creditBatch.finalizedAt = new Date().toISOString();
        
        // Transfer ownership to buyer
        creditBatch.ownerId = creditBatch.buyerId;
        delete creditBatch.buyerId;

        // Save to state
        await ctx.stub.putState(creditBatchId, Buffer.from(JSON.stringify(sortKeysRecursive(creditBatch))));

        // Emit event
        ctx.stub.setEvent('CreditsFinalized', Buffer.from(JSON.stringify({
            creditBatchId: creditBatchId,
            ownerId: creditBatch.ownerId,
            certificateHash: certificateHash
        })));

        console.info('============= END : Finalize Credits ===========');
        return JSON.stringify(creditBatch);
    }

    // ==================== QUERY FUNCTIONS ====================

    async QueryAvailableCredits(ctx) {
        console.info('============= START : Query Available Credits ===========');
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                status: CREDIT_STATUS.FOR_SALE
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info('============= END : Query Available Credits ===========');
        return JSON.stringify(results);
    }

    async QueryCreditsByFarmer(ctx, farmerId) {
        console.info(`============= START : Query Credits for Farmer ${farmerId} ===========`);
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                farmerId: farmerId
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info(`============= END : Query Credits for Farmer ${farmerId} ===========`);
        return JSON.stringify(results);
    }

    async QueryCreditsByIndustry(ctx, industryId) {
        console.info(`============= START : Query Credits for Industry ${industryId} ===========`);
        
        const queryString = {
            selector: {
                docType: 'creditBatch',
                ownerId: industryId,
                status: CREDIT_STATUS.FINALIZED
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info(`============= END : Query Credits for Industry ${industryId} ===========`);
        return JSON.stringify(results);
    }

    async GetProjectStats(ctx, projectId) {
        console.info(`============= START : Get Project Stats for ${projectId} ===========`);
        
        // Get all credits for this project
        const queryString = {
            selector: {
                docType: 'creditBatch',
                projectId: projectId
            }
        };

        let totalCredits = 0;
        let availableCredits = 0;
        let soldCredits = 0;
        let pendingCredits = 0;
        const creditBatches = [];

        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            const creditBatch = JSON.parse(value.toString());
            creditBatches.push(creditBatch);
            totalCredits += creditBatch.quantity;
            
            if (creditBatch.status === CREDIT_STATUS.AVAILABLE || creditBatch.status === CREDIT_STATUS.FOR_SALE) {
                availableCredits += creditBatch.quantity;
            } else if (creditBatch.status === CREDIT_STATUS.FINALIZED) {
                soldCredits += creditBatch.quantity;
            } else if (creditBatch.status === CREDIT_STATUS.SOLD_ESCROW) {
                pendingCredits += creditBatch.quantity;
            }
        }

        const stats = {
            projectId: projectId,
            totalCredits: totalCredits,
            availableCredits: availableCredits,
            soldCredits: soldCredits,
            pendingCredits: pendingCredits,
            creditBatches: creditBatches
        };

        console.info('============= END : Get Project Stats ===========');
        return JSON.stringify(stats);
    }

    async QueryPendingSubmissions(ctx) {
        console.info('============= START : Query Pending Submissions ===========');
        
        const queryString = {
            selector: {
                docType: 'submission',
                status: 'PENDING'
            }
        };

        const results = [];
        for await (const {key, value} of ctx.stub.getQueryResult(JSON.stringify(queryString))) {
            results.push(JSON.parse(value.toString()));
        }

        console.info('============= END : Query Pending Submissions ===========');
        return JSON.stringify(results);
    }

    async UpdateSystemConfig(ctx, key, value) {
        console.info(`============= START : Update System Config ${key} ===========`);
        
        // Get system config
        const systemConfigBytes = await ctx.stub.getState('SYSTEM_CONFIG');
        if (!systemConfigBytes || systemConfigBytes.length === 0) {
            throw new Error('System configuration not found');
        }
        const systemConfig = JSON.parse(systemConfigBytes.toString());

        // Update the specified key
        if (key === 'escrowPeriodDays' || key === 'auditPeriodDays' || key === 'minimumApprovals') {
            systemConfig[key] = parseInt(value);
        } else if (key === 'carbonCreditRate' || key === 'marketplaceFeePercent') {
            systemConfig[key] = parseFloat(value);
        } else {
            systemConfig[key] = value;
        }

        // Save updated config
        await ctx.stub.putState('SYSTEM_CONFIG', Buffer.from(JSON.stringify(sortKeysRecursive(systemConfig))));

        console.info(`============= END : Update System Config ${key} ===========`);
        return JSON.stringify(systemConfig);
    }
}

module.exports = BlueCarbonRegistry;
